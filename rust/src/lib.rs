// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use pyo3::prelude::*;
pub use shard_generated::sedpack::io::flatbuffer::shardfile::{
    root_as_shard, root_as_shard_unchecked, Attribute, Example, Shard,
};

mod example_iteration;
pub mod parallel_map;
// Import the autogenerated code for parsing a shard represented as a FlatBuffer.
// The schema is available in `src/sedpack/io/flatbuffer/shard.fbs`.
#[allow(dead_code, unused_imports)]
mod shard_generated;

/// Python wrappers around `example_iteration`.
mod static_iter {
    use std::collections::HashMap;
    use std::str::FromStr;

    use numpy::IntoPyArray;
    use pyo3::prelude::*;
    use pyo3::{pyclass, pymethods, PyRefMut};

    use super::example_iteration::{CompressionType, ExampleIterator, ShardInfo};

    /// Implementation details: The goal is to own the ExampleIterator in Rust and only send
    /// examples to Python. This helps with concurrent reading and parsing of shard files.
    /// Moreover Python code cannot compromise integrity of the data structures.
    ///
    /// - We need support for multiple ExampleIterator's at the same time since during training the
    ///   train and validation split are being read in an interleaved manner. To support this each
    ///   RustIter instance keeps a `static_index` determining which `ExampleIterator` it is using
    ///   (dispatch done using a HashMap).
    /// - Since a `HashMap` cannot be instantiated static we use an LazyLock<Mutex<HashMap>>>.
    /// - Using a mutex to avoid the need to use unsafe for a static mutable variable. The overhead
    ///   should be negligible since only a single thread is expected to access this.
    /// - Python does not guarantee that __del__ is called right away (or at all). Thus RustIter
    ///   also implements a context manager which is guaranteed to call __exit__ and drop memory
    ///   owned by the corresponding ExampleIterator.
    static STATIC_ITERATORS: std::sync::LazyLock<
        std::sync::Mutex<HashMap<usize, ExampleIterator>>,
    > = std::sync::LazyLock::new(|| std::sync::Mutex::new(HashMap::new()));

    #[pyclass]
    pub struct RustIter {
        /// Which ExampleIterator are we interacting with (unique id).
        static_index: usize,
        /// Read only value. For iteration we use this object as a context manager which allows us
        /// to free resources in STATIC_ITERATORS on the call of __exit__.
        ///
        /// Alternatives considered:
        /// - __del__ is not yet supported by pyo3 and also not guaranteed to be called by Python.
        #[pyo3(get)]
        can_iterate: bool,
    }

    impl Iterator for RustIter {
        type Item = <ExampleIterator as Iterator>::Item;

        fn next(&mut self) -> Option<Self::Item> {
            // TODO move println to logging.
            if !self.can_iterate {
                println!(
                    "Use the context manager to enable iteration and guaranteed memory \
                     deallocation"
                );
                return None;
            }
            let mut hash_map = STATIC_ITERATORS.lock().unwrap();
            let iter = hash_map
                .get_mut(&self.static_index)
                .expect("The static_index was not found among the STATIC_ITERATORS.");
            iter.next()
        }
    }

    #[pymethods]
    impl RustIter {
        #[new]
        fn new(files: Vec<String>, repeat: bool, threads: usize, compression: String) -> Self {
            let static_index = rand::random();
            let mut hash_map = STATIC_ITERATORS.lock().unwrap();
            let compression_type = CompressionType::from_str(&compression).unwrap();
            let shard_infos = files
                .into_iter()
                .map(|file_path| ShardInfo { file_path: file_path.clone(), compression_type })
                .collect();
            hash_map.insert(static_index, ExampleIterator::new(shard_infos, repeat, threads));

            RustIter { static_index, can_iterate: false }
        }

        #[staticmethod]
        fn supported_compressions() -> Vec<String> {
            CompressionType::supported_compressions()
        }

        fn __iter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {
            slf
        }

        fn __next__<'py>(
            mut slf: PyRefMut<'py, Self>,
        ) -> Option<Vec<Bound<'py, numpy::PyArray<u8, numpy::Ix1>>>> {
            match slf.next() {
                None => None,
                Some(result) => {
                    // Prepare data back for Python. Wrap in NumPy arrays so that we are passing
                    // only a pointer and not copying data around. Each
                    // attribute is accepted directly by NumPy. There should be no
                    // additional memory copies.
                    let np_result: Vec<Bound<'py, numpy::PyArray<u8, numpy::Ix1>>> = result
                        .into_iter()
                        .map(numpy::ndarray::Array::from_vec)
                        .map(|x| x.into_pyarray(slf.py()))
                        .collect();

                    Some(np_result)
                }
            }
        }

        /// The implementation is reentrant. If changing also change
        /// `sedpack.io.dataset_iteration.RustGenerator`.
        fn __enter__(mut slf: PyRefMut<'_, Self>) -> PyRefMut<'_, Self> {
            slf.can_iterate = true;
            slf
        }

        fn __exit__(
            mut slf: PyRefMut<'_, Self>, _exc_type: &Bound<'_, PyAny>, _exc_val: &Bound<'_, PyAny>,
            _exc_tb: &Bound<'_, PyAny>,
        ) {
            slf.can_iterate = false;
            // Drop from STATIC_ITERATORS.
            let mut hash_map = STATIC_ITERATORS.lock().unwrap();
            drop(hash_map.remove(&slf.static_index));
        }
    }
}

/// A Python module implemented in Rust.
#[pymodule]
fn _sedpack_rs(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<static_iter::RustIter>()?;
    Ok(())
}
