// Copyright 2024-2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use pyo3::prelude::*;
pub use shard_generated::sedpack::io::flatbuffer::shardfile::{
    root_as_shard, root_as_shard_unchecked, Attribute, Example, Shard,
};

pub mod batch_iteration;
pub mod example_iteration;
pub mod parallel_map;
// Import the autogenerated code for parsing a shard represented as a FlatBuffer.
// The schema is available in `src/sedpack/io/flatbuffer/shard.fbs`.
#[allow(dead_code, unused_imports)]
mod shard_generated;

/// Python wrappers around `example_iteration`.
mod static_iter {
    use std::collections::HashMap;
    use std::str::FromStr;

    use numpy::IntoPyArray;
    use pyo3::prelude::*;
    use pyo3::{pyclass, pymethods, PyRefMut};

    use super::example_iteration::{CompressionType, ExampleIterator, ShardInfo};

    /// Implementation details: The goal is to own the ExampleIterator in Rust and only send
    /// examples to Python. This helps with concurrent reading and parsing of shard files.
    /// Moreover Python code cannot compromise integrity of the data structures.
    ///
    /// - We need support for multiple ExampleIterator's at the same time since during training the
    ///   train and validation split are being read in an interleaved manner. To support this each
    ///   RustIter instance keeps a `static_index` determining which `ExampleIterator` it is using
    ///   (dispatch done using a HashMap).
    /// - Since a `HashMap` cannot be instantiated static we use an LazyLock<Mutex<HashMap>>>.
    /// - Using a mutex to avoid the need to use unsafe for a static mutable variable. The overhead
    ///   should be negligible since only a single thread is expected to access this.
    /// - Python does not guarantee that __del__ is called right away (or at all). Thus RustIter
    ///   also implements a context manager which is guaranteed to call __exit__ and drop memory
    ///   owned by the corresponding ExampleIterator.
    static STATIC_ITERATORS: std::sync::LazyLock<std::sync::Mutex<HashMap<i32, ExampleIterator>>> =
        std::sync::LazyLock::new(|| std::sync::Mutex::new(HashMap::new()));

    #[pyclass]
    pub struct RustIter {
        /// Which ExampleIterator are we interacting with (unique id).
        static_index: i32,
        /// Read only value. For iteration we use this object as a context manager which allows us
        /// to free resources in STATIC_ITERATORS on the call of __exit__.
        ///
        /// Alternatives considered:
        /// - __del__ is not yet supported by pyo3 and also not guaranteed to be called by Python.
        #[pyo3(get)]
        can_iterate: bool,
    }

    impl Iterator for RustIter {
        type Item = <ExampleIterator as Iterator>::Item;

        fn next(&mut self) -> Option<Self::Item> {
            // TODO move println to logging.
            if !self.can_iterate {
                println!(
                    "Use the context manager to enable iteration and guaranteed memory \
                     deallocation"
                );
                return None;
            }
            let mut hash_map = STATIC_ITERATORS.lock().unwrap();
            let iter = hash_map
                .get_mut(&self.static_index)
                .expect("The static_index was not found among the STATIC_ITERATORS.");
            iter.next()
        }
    }

    #[pymethods]
    impl RustIter {
        #[new]
        fn new(files: Vec<String>, threads: usize, compression: String) -> Self {
            let static_index = rand::random();
            let mut hash_map = STATIC_ITERATORS.lock().unwrap();
            let compression_type = CompressionType::from_str(&compression).unwrap();
            let shard_infos = files
                .into_iter()
                .map(|file_path| ShardInfo { file_path, compression_type })
                .collect();
            hash_map.insert(static_index, ExampleIterator::new(shard_infos, threads));

            RustIter { static_index, can_iterate: false }
        }

        #[staticmethod]
        fn supported_compressions() -> Vec<String> {
            CompressionType::supported_compressions()
        }

        fn __iter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {
            slf
        }

        fn __next__<'py>(
            mut slf: PyRefMut<'py, Self>,
        ) -> Option<Vec<Bound<'py, numpy::PyArray<u8, numpy::Ix1>>>> {
            match slf.next() {
                None => None,
                Some(result) => {
                    // Prepare data back for Python. Wrap in NumPy arrays so that we are passing
                    // only a pointer and not copying data around. Each
                    // attribute is accepted directly by NumPy. There should be no
                    // additional memory copies.
                    let np_result: Vec<Bound<'py, numpy::PyArray<u8, numpy::Ix1>>> = result
                        .into_iter()
                        .map(numpy::ndarray::Array::from_vec)
                        .map(|x| x.into_pyarray(slf.py()))
                        .collect();

                    Some(np_result)
                }
            }
        }

        /// The implementation is reentrant. If changing also change
        /// `sedpack.io.dataset_iteration.RustGenerator`.
        fn __enter__(mut slf: PyRefMut<'_, Self>) -> PyRefMut<'_, Self> {
            slf.can_iterate = true;
            slf
        }

        fn __exit__(
            mut slf: PyRefMut<'_, Self>, _exc_type: &Bound<'_, PyAny>, _exc_val: &Bound<'_, PyAny>,
            _exc_tb: &Bound<'_, PyAny>,
        ) {
            slf.can_iterate = false;
            // Drop from STATIC_ITERATORS.
            let mut hash_map = STATIC_ITERATORS.lock().unwrap();
            drop(hash_map.remove(&slf.static_index));
        }
    }
}

/// Python wrappers around `example_iteration`.
mod static_batched_iter {
    use std::collections::HashMap;
    use std::str::FromStr;

    use numpy::IntoPyArray;
    use pyo3::prelude::*;
    use pyo3::{pyclass, pymethods, PyRefMut};
    use tracing::{span, Level};

    use super::batch_iteration::{BatchIterator, BatchedAttribute};
    use super::example_iteration::{CompressionType, ShardInfo};

    /// Implementation details: The goal is to own the BatchIterator in Rust and only send
    /// examples to Python. This helps with concurrent reading and parsing of shard files.
    /// Moreover Python code cannot compromise integrity of the data structures.
    ///
    /// - We need support for multiple BatchIterator's at the same time since during training the
    ///   train and validation split are being read in an interleaved manner. To support this each
    ///   RustIter instance keeps a `static_index` determining which `BatchIterator` it is using
    ///   (dispatch done using a HashMap).
    /// - Since a `HashMap` cannot be instantiated static we use an LazyLock<Mutex<HashMap>>>.
    /// - Using a mutex to avoid the need to use unsafe for a static mutable variable. The overhead
    ///   should be negligible since only a single thread is expected to access this.
    /// - Python does not guarantee that __del__ is called right away (or at all). Thus RustIter
    ///   also implements a context manager which is guaranteed to call __exit__ and drop memory
    ///   owned by the corresponding BatchIterator.
    static STATIC_ITERATORS: std::sync::LazyLock<std::sync::Mutex<HashMap<i32, BatchIterator>>> =
        std::sync::LazyLock::new(|| std::sync::Mutex::new(HashMap::new()));

    #[pyclass]
    pub struct BatchedRustIter {
        /// Which BatchIterator are we interacting with (unique id). Experimental API expect
        /// breaking changes.
        static_index: i32,
        /// Read only value. For iteration we use this object as a context manager which allows us
        /// to free resources in STATIC_ITERATORS on the call of __exit__.
        ///
        /// Alternatives considered:
        /// - __del__ is not yet supported by pyo3 and also not guaranteed to be called by Python.
        #[pyo3(get)]
        can_iterate: bool,
    }

    impl Iterator for BatchedRustIter {
        type Item = <BatchIterator as Iterator>::Item;

        fn next(&mut self) -> Option<Self::Item> {
            // TODO move println to logging.
            if !self.can_iterate {
                println!(
                    "Use the context manager to enable iteration and guaranteed memory \
                     deallocation"
                );
                return None;
            }
            let mut hash_map = STATIC_ITERATORS.lock().unwrap();
            let iter = hash_map
                .get_mut(&self.static_index)
                .expect("The static_index was not found among the STATIC_ITERATORS.");
            iter.next()
        }
    }

    #[pymethods]
    impl BatchedRustIter {
        #[new]
        fn new(
            files: Vec<String>, threads: usize, compression: String, batch_size: usize,
            has_fixed_shape: Vec<bool>,
        ) -> Self {
            let static_index = rand::random();
            let mut hash_map = STATIC_ITERATORS.lock().unwrap();
            let compression_type = CompressionType::from_str(&compression).unwrap();
            let shard_infos = files
                .into_iter()
                .map(|file_path| ShardInfo { file_path, compression_type })
                .collect();
            hash_map.insert(
                static_index,
                BatchIterator::new(shard_infos, threads, batch_size, has_fixed_shape),
            );

            BatchedRustIter { static_index, can_iterate: false }
        }

        #[staticmethod]
        fn supported_compressions() -> Vec<String> {
            CompressionType::supported_compressions()
        }

        fn __iter__(slf: PyRef<'_, Self>) -> PyRef<'_, Self> {
            slf
        }

        /// Yields another batch of examples. Attributes are batched in the following way:
        ///
        /// - static (fixed shape) is row-major order (C-order) numpy array batch of attribute
        /// values.
        ///
        /// - dynamic (unknown shape, e.g., str, bytes) list of numpy arrays.
        fn __next__<'py>(mut slf: PyRefMut<'py, Self>) -> Option<Bound<'py, pyo3::types::PyList>> {
            let span = span!(Level::TRACE, "BatchedRustIter.__next__");
            let _enter = span.enter();

            match slf.next() {
                None => None,
                Some(result) => {
                    let elements: Vec<Bound<'py, PyAny>> = result
                        .into_iter()
                        .map(|batched_attribute| match batched_attribute {
                            BatchedAttribute::Static { data } => {
                                data.into_pyarray(slf.py()).into_any()
                            }
                            BatchedAttribute::Dynamic { data } => pyo3::types::PyList::new(
                                slf.py(),
                                data.into_iter().map(|e| e.into_pyarray(slf.py())),
                            )
                            .unwrap()
                            .into_any(),
                        })
                        .collect();
                    Some(pyo3::types::PyList::new(slf.py(), elements).unwrap())
                }
            }
        }

        /// The implementation is reentrant. If changing also change
        /// `sedpack.io.dataset_iteration.RustGenerator`.
        fn __enter__(mut slf: PyRefMut<'_, Self>) -> PyRefMut<'_, Self> {
            slf.can_iterate = true;
            slf
        }

        fn __exit__(
            mut slf: PyRefMut<'_, Self>, _exc_type: &Bound<'_, PyAny>, _exc_val: &Bound<'_, PyAny>,
            _exc_tb: &Bound<'_, PyAny>,
        ) {
            slf.can_iterate = false;
            // Drop from STATIC_ITERATORS.
            let mut hash_map = STATIC_ITERATORS.lock().unwrap();
            drop(hash_map.remove(&slf.static_index));
        }
    }
}

mod sedpack_tracing {
    use pyo3::{pyclass, pymethods};
    use tracing_perfetto::PerfettoLayer;
    use tracing_subscriber::prelude::*;

    #[pyclass]
    pub struct TracingControl {}

    #[pymethods]
    impl TracingControl {
        /// set_perfetto_output(file_name: str) -> None
        /// --
        ///
        /// Set the output file for tracing. The output is a binary file readable either using
        /// - UI available at: https://ui.perfetto.dev/
        /// - Python code: https://perfetto.dev/docs/analysis/trace-processor-python
        #[staticmethod]
        fn set_perfetto_output(file_name: String) {
            let layer = PerfettoLayer::new(std::sync::Mutex::new(
                std::fs::File::create(file_name).unwrap(),
            ));
            tracing_subscriber::registry().with(layer).init();
        }
    }
}

/// A Python module implemented in Rust.
#[pymodule]
fn _sedpack_rs(m: &Bound<'_, PyModule>) -> PyResult<()> {
    m.add_class::<static_iter::RustIter>()?;
    m.add_class::<static_batched_iter::BatchedRustIter>()?;
    m.add_class::<sedpack_tracing::TracingControl>()?;
    Ok(())
}
