// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod sedpack {
    // Ignore clippy warnings since this is autogenerated code:
    #![allow(clippy::all)]

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};
    #[allow(unused_imports, dead_code)]
    pub mod io {

        use core::cmp::Ordering;
        use core::mem;

        extern crate flatbuffers;
        use self::flatbuffers::{EndianScalar, Follow};
        #[allow(unused_imports, dead_code)]
        pub mod flatbuffer {

            use core::cmp::Ordering;
            use core::mem;

            extern crate flatbuffers;
            use self::flatbuffers::{EndianScalar, Follow};
            #[allow(unused_imports, dead_code)]
            pub mod shardfile {

                use core::cmp::Ordering;
                use core::mem;

                extern crate flatbuffers;
                use self::flatbuffers::{EndianScalar, Follow};

                pub enum AttributeOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Attribute<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Attribute<'a> {
                    type Inner = Attribute<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self { _tab: flatbuffers::Table::new(buf, loc) }
                    }
                }

                impl<'a> Attribute<'a> {
                    pub const VT_ATTRIBUTE_BYTES: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Attribute { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args AttributeArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Attribute<'bldr>> {
                        let mut builder = AttributeBuilder::new(_fbb);
                        if let Some(x) = args.attribute_bytes {
                            builder.add_attribute_bytes(x);
                        }
                        builder.finish()
                    }

                    #[inline]
                    pub fn attribute_bytes(&self) -> Option<flatbuffers::Vector<'a, u8>> {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab
                                .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                                    Attribute::VT_ATTRIBUTE_BYTES,
                                    None,
                                )
                        }
                    }
                }

                impl flatbuffers::Verifiable for Attribute<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier, pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("attribute_bytes", Self::VT_ATTRIBUTE_BYTES, false)?
     .finish();
                        Ok(())
                    }
                }
                pub struct AttributeArgs<'a> {
                    pub attribute_bytes:
                        Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
                }
                impl<'a> Default for AttributeArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        AttributeArgs { attribute_bytes: None }
                    }
                }

                pub struct AttributeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> AttributeBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_attribute_bytes(
                        &mut self,
                        attribute_bytes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Attribute::VT_ATTRIBUTE_BYTES,
                            attribute_bytes,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> AttributeBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        AttributeBuilder { fbb_: _fbb, start_: start }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Attribute<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for Attribute<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("Attribute");
                        ds.field("attribute_bytes", &self.attribute_bytes());
                        ds.finish()
                    }
                }
                pub enum ExampleOffset {}
                #[derive(Copy, Clone, PartialEq)]

                pub struct Example<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Example<'a> {
                    type Inner = Example<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self { _tab: flatbuffers::Table::new(buf, loc) }
                    }
                }

                impl<'a> Example<'a> {
                    pub const VT_ATTRIBUTES: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Example { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args ExampleArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Example<'bldr>> {
                        let mut builder = ExampleBuilder::new(_fbb);
                        if let Some(x) = args.attributes {
                            builder.add_attributes(x);
                        }
                        builder.finish()
                    }

                    #[inline]
                    pub fn attributes(
                        &self,
                    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Attribute<'a>>>>
                    {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Attribute>>,
                            >>(Example::VT_ATTRIBUTES, None)
                        }
                    }
                }

                impl flatbuffers::Verifiable for Example<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier, pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Attribute>>,
                            >>("attributes", Self::VT_ATTRIBUTES, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct ExampleArgs<'a> {
                    pub attributes: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Attribute<'a>>>,
                        >,
                    >,
                }
                impl<'a> Default for ExampleArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        ExampleArgs { attributes: None }
                    }
                }

                pub struct ExampleBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ExampleBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_attributes(
                        &mut self,
                        attributes: flatbuffers::WIPOffset<
                            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Attribute<'b>>>,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Example::VT_ATTRIBUTES,
                            attributes,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> ExampleBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        ExampleBuilder { fbb_: _fbb, start_: start }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Example<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for Example<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("Example");
                        ds.field("attributes", &self.attributes());
                        ds.finish()
                    }
                }
                pub enum ShardOffset {}

                // Added Yokeable to the autogenerated code.
                #[derive(Copy, Clone, PartialEq, yoke::Yokeable)]
                pub struct Shard<'a> {
                    pub _tab: flatbuffers::Table<'a>,
                }

                impl<'a> flatbuffers::Follow<'a> for Shard<'a> {
                    type Inner = Shard<'a>;
                    #[inline]
                    unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
                        Self { _tab: flatbuffers::Table::new(buf, loc) }
                    }
                }

                impl<'a> Shard<'a> {
                    pub const VT_EXAMPLES: flatbuffers::VOffsetT = 4;

                    #[inline]
                    pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
                        Shard { _tab: table }
                    }
                    #[allow(unused_mut)]
                    pub fn create<
                        'bldr: 'args,
                        'args: 'mut_bldr,
                        'mut_bldr,
                        A: flatbuffers::Allocator + 'bldr,
                    >(
                        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
                        args: &'args ShardArgs<'args>,
                    ) -> flatbuffers::WIPOffset<Shard<'bldr>> {
                        let mut builder = ShardBuilder::new(_fbb);
                        if let Some(x) = args.examples {
                            builder.add_examples(x);
                        }
                        builder.finish()
                    }

                    #[inline]
                    pub fn examples(
                        &self,
                    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Example<'a>>>>
                    {
                        // Safety:
                        // Created from valid Table for this object
                        // which contains a valid value in this slot
                        unsafe {
                            self._tab.get::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Example>>,
                            >>(Shard::VT_EXAMPLES, None)
                        }
                    }
                }

                impl flatbuffers::Verifiable for Shard<'_> {
                    #[inline]
                    fn run_verifier(
                        v: &mut flatbuffers::Verifier, pos: usize,
                    ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
                        use self::flatbuffers::Verifiable;
                        v.visit_table(pos)?
                            .visit_field::<flatbuffers::ForwardsUOffset<
                                flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Example>>,
                            >>("examples", Self::VT_EXAMPLES, false)?
                            .finish();
                        Ok(())
                    }
                }
                pub struct ShardArgs<'a> {
                    pub examples: Option<
                        flatbuffers::WIPOffset<
                            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Example<'a>>>,
                        >,
                    >,
                }
                impl<'a> Default for ShardArgs<'a> {
                    #[inline]
                    fn default() -> Self {
                        ShardArgs { examples: None }
                    }
                }

                pub struct ShardBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
                    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
                }
                impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ShardBuilder<'a, 'b, A> {
                    #[inline]
                    pub fn add_examples(
                        &mut self,
                        examples: flatbuffers::WIPOffset<
                            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<Example<'b>>>,
                        >,
                    ) {
                        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                            Shard::VT_EXAMPLES,
                            examples,
                        );
                    }
                    #[inline]
                    pub fn new(
                        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    ) -> ShardBuilder<'a, 'b, A> {
                        let start = _fbb.start_table();
                        ShardBuilder { fbb_: _fbb, start_: start }
                    }
                    #[inline]
                    pub fn finish(self) -> flatbuffers::WIPOffset<Shard<'a>> {
                        let o = self.fbb_.end_table(self.start_);
                        flatbuffers::WIPOffset::new(o.value())
                    }
                }

                impl core::fmt::Debug for Shard<'_> {
                    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
                        let mut ds = f.debug_struct("Shard");
                        ds.field("examples", &self.examples());
                        ds.finish()
                    }
                }
                #[inline]
                /// Verifies that a buffer of bytes contains a `Shard`
                /// and returns it.
                /// Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `root_as_shard_unchecked`.
                pub fn root_as_shard(buf: &[u8]) -> Result<Shard, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::root::<Shard>(buf)
                }
                #[inline]
                /// Verifies that a buffer of bytes contains a size prefixed
                /// `Shard` and returns it.
                /// Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `size_prefixed_root_as_shard_unchecked`.
                pub fn size_prefixed_root_as_shard(
                    buf: &[u8],
                ) -> Result<Shard, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::size_prefixed_root::<Shard>(buf)
                }
                #[inline]
                /// Verifies, with the given options, that a buffer of bytes
                /// contains a `Shard` and returns it.
                /// Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `root_as_shard_unchecked`.
                pub fn root_as_shard_with_opts<'b, 'o>(
                    opts: &'o flatbuffers::VerifierOptions, buf: &'b [u8],
                ) -> Result<Shard<'b>, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::root_with_opts::<Shard<'b>>(opts, buf)
                }
                #[inline]
                /// Verifies, with the given verifier options, that a buffer of
                /// bytes contains a size prefixed `Shard` and returns
                /// it. Note that verification is still experimental and may not
                /// catch every error, or be maximally performant. For the
                /// previous, unchecked, behavior use
                /// `root_as_shard_unchecked`.
                pub fn size_prefixed_root_as_shard_with_opts<'b, 'o>(
                    opts: &'o flatbuffers::VerifierOptions, buf: &'b [u8],
                ) -> Result<Shard<'b>, flatbuffers::InvalidFlatbuffer> {
                    flatbuffers::size_prefixed_root_with_opts::<Shard<'b>>(opts, buf)
                }
                #[inline]
                /// Assumes, without verification, that a buffer of bytes contains a Shard and returns it.
                /// # Safety
                /// Callers must trust the given bytes do indeed contain a valid `Shard`.
                pub unsafe fn root_as_shard_unchecked(buf: &[u8]) -> Shard {
                    flatbuffers::root_unchecked::<Shard>(buf)
                }
                #[inline]
                /// Assumes, without verification, that a buffer of bytes contains a size prefixed Shard and returns it.
                /// # Safety
                /// Callers must trust the given bytes do indeed contain a valid size prefixed `Shard`.
                pub unsafe fn size_prefixed_root_as_shard_unchecked(buf: &[u8]) -> Shard {
                    flatbuffers::size_prefixed_root_unchecked::<Shard>(buf)
                }
                #[inline]
                pub fn finish_shard_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
                    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    root: flatbuffers::WIPOffset<Shard<'a>>,
                ) {
                    fbb.finish(root, None);
                }

                #[inline]
                pub fn finish_size_prefixed_shard_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
                    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
                    root: flatbuffers::WIPOffset<Shard<'a>>,
                ) {
                    fbb.finish_size_prefixed(root, None);
                }
            } // pub mod shardfile
        } // pub mod flatbuffer
    } // pub mod io
} // pub mod sedpack
